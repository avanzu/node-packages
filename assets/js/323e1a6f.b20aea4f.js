"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[354],{471:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"kernel/Scaffolding/feature-slices","title":"FeatureSlice style","description":"As an alternative structure and philosophy, your application can be organized around vertically sliced features (or \\"modules\\"), which aim to keep all related concerns together \u2014 rather than scattering them across architectural layers.","source":"@site/docs/kernel/2 - Scaffolding/3-feature-slices.md","sourceDirName":"kernel/2 - Scaffolding","slug":"/kernel/Scaffolding/feature-slices","permalink":"/node-packages/docs/kernel/Scaffolding/feature-slices","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"FeatureSlice style","sidebar_label":"FeatureSlice style"},"sidebar":"kernelSidebar","previous":{"title":"Hexagonal style","permalink":"/node-packages/docs/kernel/Scaffolding/hexagonal"}}');var a=t(4848),i=t(8453);const o={title:"FeatureSlice style",sidebar_label:"FeatureSlice style"},l=void 0,s={},c=[{value:"Folder structure",id:"folder-structure",level:2},{value:"The application layer",id:"the-application-layer",level:2},{value:"integration with container modules",id:"integration-with-container-modules",level:3}];function u(e){const n={blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:'As an alternative structure and philosophy, your application can be organized around vertically sliced features (or "modules"), which aim to keep all related concerns together \u2014 rather than scattering them across architectural layers.'}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Hint:"})," If you intend to go ",(0,a.jsx)(n.em,{children:"really"})," micro so that a single service is supposed to be a single feature, this section will most likely provide no benefit to you."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"folder-structure",children:"Folder structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"myproject/\n    src/\n        main.ts\n        application/\n            kernel.ts\n            controllers/\n            dependencyInjection/\n                containerBuilder.ts\n                index.ts\n        features/\n            myfeature/\n                entities/\n                infrastructure/\n                useCases/\n                module.ts\n"})}),"\n",(0,a.jsx)(n.p,{children:"In essence, your feature slices are internally layered just like the hexagonal approach. You just keep everything that logically belongs to a specific feature together in one place."}),"\n",(0,a.jsx)(n.h2,{id:"the-application-layer",children:"The application layer"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"/application"})," folder remains almost exactly the same as with the hexagonal approach. We still need some place to integrate the individual parts."]}),"\n",(0,a.jsx)(n.h3,{id:"integration-with-container-modules",children:"integration with container modules"}),"\n",(0,a.jsxs)(n.p,{children:["To plug a feature slice into your application, define a ",(0,a.jsx)(n.code,{children:"ContainerModule"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// myproject/src/features/myfeature/module.ts\nimport * as Kernel from '@avanzu/kernel'\n// declare which dependencies will be registered in the application container\nexport type MyFeatureExports = {}\n// declare whih dependencies are expected to be available in the application container\nexport type MyFeatureImports = {}\n\nexport class MyFeatureContainerModule implements Kernel.ContainerModule<MyFeatureExports, MyFeatureImports> {\n\n    getName(): string {\n        // make sure to return a unique name.\n        // Be cautious around bundlers which will often rename classes\n        return this.constructor.name\n    }\n\n    configure(container: Kernel.Container<MyFeatureExports & MyFeatureImports>) : void {\n        // register your exports\n    }\n\n    getEventhandlers(): Kernel.EventHandlerSpec[] {\n        return []\n    }\n}\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then, register the module in your application's container builder:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// myproject/src/application/dependencyInjection/containerBuilder.ts\n\nimport { MyFeatureContainerModule } from '~/features/myfeature'\n\nexport class ContainerBuilder extends Kernel.AbstractContainerBuilder<Container> {\n\n    getModules(): ContainerModule<any> {\n        return [ new MyFeatureContainerModule() ]\n    }\n\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var r=t(6540);const a={},i=r.createContext(a);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);